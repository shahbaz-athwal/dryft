
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * This file exports the `CourseProfessor` model and its related types.
 *
 * ðŸŸ¢ You can import this file directly.
 */
import type * as runtime from "@prisma/client/runtime/client"
import type * as $Enums from "../enums"
import type * as Prisma from "../internal/prismaNamespace"

/**
 * Model CourseProfessor
 * 
 */
export type CourseProfessorModel = runtime.Types.Result.DefaultSelection<Prisma.$CourseProfessorPayload>

export type AggregateCourseProfessor = {
  _count: CourseProfessorCountAggregateOutputType | null
  _min: CourseProfessorMinAggregateOutputType | null
  _max: CourseProfessorMaxAggregateOutputType | null
}

export type CourseProfessorMinAggregateOutputType = {
  id: string | null
  courseId: string | null
  professorId: string | null
}

export type CourseProfessorMaxAggregateOutputType = {
  id: string | null
  courseId: string | null
  professorId: string | null
}

export type CourseProfessorCountAggregateOutputType = {
  id: number
  courseId: number
  professorId: number
  _all: number
}


export type CourseProfessorMinAggregateInputType = {
  id?: true
  courseId?: true
  professorId?: true
}

export type CourseProfessorMaxAggregateInputType = {
  id?: true
  courseId?: true
  professorId?: true
}

export type CourseProfessorCountAggregateInputType = {
  id?: true
  courseId?: true
  professorId?: true
  _all?: true
}

export type CourseProfessorAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which CourseProfessor to aggregate.
   */
  where?: Prisma.CourseProfessorWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of CourseProfessors to fetch.
   */
  orderBy?: Prisma.CourseProfessorOrderByWithRelationInput | Prisma.CourseProfessorOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the start position
   */
  cursor?: Prisma.CourseProfessorWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` CourseProfessors from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` CourseProfessors.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Count returned CourseProfessors
  **/
  _count?: true | CourseProfessorCountAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the minimum value
  **/
  _min?: CourseProfessorMinAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the maximum value
  **/
  _max?: CourseProfessorMaxAggregateInputType
}

export type GetCourseProfessorAggregateType<T extends CourseProfessorAggregateArgs> = {
      [P in keyof T & keyof AggregateCourseProfessor]: P extends '_count' | 'count'
    ? T[P] extends true
      ? number
      : Prisma.GetScalarType<T[P], AggregateCourseProfessor[P]>
    : Prisma.GetScalarType<T[P], AggregateCourseProfessor[P]>
}




export type CourseProfessorGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.CourseProfessorWhereInput
  orderBy?: Prisma.CourseProfessorOrderByWithAggregationInput | Prisma.CourseProfessorOrderByWithAggregationInput[]
  by: Prisma.CourseProfessorScalarFieldEnum[] | Prisma.CourseProfessorScalarFieldEnum
  having?: Prisma.CourseProfessorScalarWhereWithAggregatesInput
  take?: number
  skip?: number
  _count?: CourseProfessorCountAggregateInputType | true
  _min?: CourseProfessorMinAggregateInputType
  _max?: CourseProfessorMaxAggregateInputType
}

export type CourseProfessorGroupByOutputType = {
  id: string
  courseId: string
  professorId: string
  _count: CourseProfessorCountAggregateOutputType | null
  _min: CourseProfessorMinAggregateOutputType | null
  _max: CourseProfessorMaxAggregateOutputType | null
}

type GetCourseProfessorGroupByPayload<T extends CourseProfessorGroupByArgs> = Prisma.PrismaPromise<
  Array<
    Prisma.PickEnumerable<CourseProfessorGroupByOutputType, T['by']> &
      {
        [P in ((keyof T) & (keyof CourseProfessorGroupByOutputType))]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : Prisma.GetScalarType<T[P], CourseProfessorGroupByOutputType[P]>
          : Prisma.GetScalarType<T[P], CourseProfessorGroupByOutputType[P]>
      }
    >
  >



export type CourseProfessorWhereInput = {
  AND?: Prisma.CourseProfessorWhereInput | Prisma.CourseProfessorWhereInput[]
  OR?: Prisma.CourseProfessorWhereInput[]
  NOT?: Prisma.CourseProfessorWhereInput | Prisma.CourseProfessorWhereInput[]
  id?: Prisma.StringFilter<"CourseProfessor"> | string
  courseId?: Prisma.StringFilter<"CourseProfessor"> | string
  professorId?: Prisma.StringFilter<"CourseProfessor"> | string
  course?: Prisma.XOR<Prisma.CourseScalarRelationFilter, Prisma.CourseWhereInput>
  professor?: Prisma.XOR<Prisma.ProfessorScalarRelationFilter, Prisma.ProfessorWhereInput>
}

export type CourseProfessorOrderByWithRelationInput = {
  id?: Prisma.SortOrder
  courseId?: Prisma.SortOrder
  professorId?: Prisma.SortOrder
  course?: Prisma.CourseOrderByWithRelationInput
  professor?: Prisma.ProfessorOrderByWithRelationInput
}

export type CourseProfessorWhereUniqueInput = Prisma.AtLeast<{
  id?: string
  courseId_professorId?: Prisma.CourseProfessorCourseIdProfessorIdCompoundUniqueInput
  AND?: Prisma.CourseProfessorWhereInput | Prisma.CourseProfessorWhereInput[]
  OR?: Prisma.CourseProfessorWhereInput[]
  NOT?: Prisma.CourseProfessorWhereInput | Prisma.CourseProfessorWhereInput[]
  courseId?: Prisma.StringFilter<"CourseProfessor"> | string
  professorId?: Prisma.StringFilter<"CourseProfessor"> | string
  course?: Prisma.XOR<Prisma.CourseScalarRelationFilter, Prisma.CourseWhereInput>
  professor?: Prisma.XOR<Prisma.ProfessorScalarRelationFilter, Prisma.ProfessorWhereInput>
}, "id" | "courseId_professorId">

export type CourseProfessorOrderByWithAggregationInput = {
  id?: Prisma.SortOrder
  courseId?: Prisma.SortOrder
  professorId?: Prisma.SortOrder
  _count?: Prisma.CourseProfessorCountOrderByAggregateInput
  _max?: Prisma.CourseProfessorMaxOrderByAggregateInput
  _min?: Prisma.CourseProfessorMinOrderByAggregateInput
}

export type CourseProfessorScalarWhereWithAggregatesInput = {
  AND?: Prisma.CourseProfessorScalarWhereWithAggregatesInput | Prisma.CourseProfessorScalarWhereWithAggregatesInput[]
  OR?: Prisma.CourseProfessorScalarWhereWithAggregatesInput[]
  NOT?: Prisma.CourseProfessorScalarWhereWithAggregatesInput | Prisma.CourseProfessorScalarWhereWithAggregatesInput[]
  id?: Prisma.StringWithAggregatesFilter<"CourseProfessor"> | string
  courseId?: Prisma.StringWithAggregatesFilter<"CourseProfessor"> | string
  professorId?: Prisma.StringWithAggregatesFilter<"CourseProfessor"> | string
}

export type CourseProfessorCreateInput = {
  id?: string
  course: Prisma.CourseCreateNestedOneWithoutProfessorsInput
  professor: Prisma.ProfessorCreateNestedOneWithoutCoursesInput
}

export type CourseProfessorUncheckedCreateInput = {
  id?: string
  courseId: string
  professorId: string
}

export type CourseProfessorUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  course?: Prisma.CourseUpdateOneRequiredWithoutProfessorsNestedInput
  professor?: Prisma.ProfessorUpdateOneRequiredWithoutCoursesNestedInput
}

export type CourseProfessorUncheckedUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  courseId?: Prisma.StringFieldUpdateOperationsInput | string
  professorId?: Prisma.StringFieldUpdateOperationsInput | string
}

export type CourseProfessorCreateManyInput = {
  id?: string
  courseId: string
  professorId: string
}

export type CourseProfessorUpdateManyMutationInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
}

export type CourseProfessorUncheckedUpdateManyInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  courseId?: Prisma.StringFieldUpdateOperationsInput | string
  professorId?: Prisma.StringFieldUpdateOperationsInput | string
}

export type CourseProfessorListRelationFilter = {
  every?: Prisma.CourseProfessorWhereInput
  some?: Prisma.CourseProfessorWhereInput
  none?: Prisma.CourseProfessorWhereInput
}

export type CourseProfessorOrderByRelationAggregateInput = {
  _count?: Prisma.SortOrder
}

export type CourseProfessorCourseIdProfessorIdCompoundUniqueInput = {
  courseId: string
  professorId: string
}

export type CourseProfessorCountOrderByAggregateInput = {
  id?: Prisma.SortOrder
  courseId?: Prisma.SortOrder
  professorId?: Prisma.SortOrder
}

export type CourseProfessorMaxOrderByAggregateInput = {
  id?: Prisma.SortOrder
  courseId?: Prisma.SortOrder
  professorId?: Prisma.SortOrder
}

export type CourseProfessorMinOrderByAggregateInput = {
  id?: Prisma.SortOrder
  courseId?: Prisma.SortOrder
  professorId?: Prisma.SortOrder
}

export type CourseProfessorCreateNestedManyWithoutProfessorInput = {
  create?: Prisma.XOR<Prisma.CourseProfessorCreateWithoutProfessorInput, Prisma.CourseProfessorUncheckedCreateWithoutProfessorInput> | Prisma.CourseProfessorCreateWithoutProfessorInput[] | Prisma.CourseProfessorUncheckedCreateWithoutProfessorInput[]
  connectOrCreate?: Prisma.CourseProfessorCreateOrConnectWithoutProfessorInput | Prisma.CourseProfessorCreateOrConnectWithoutProfessorInput[]
  createMany?: Prisma.CourseProfessorCreateManyProfessorInputEnvelope
  connect?: Prisma.CourseProfessorWhereUniqueInput | Prisma.CourseProfessorWhereUniqueInput[]
}

export type CourseProfessorUncheckedCreateNestedManyWithoutProfessorInput = {
  create?: Prisma.XOR<Prisma.CourseProfessorCreateWithoutProfessorInput, Prisma.CourseProfessorUncheckedCreateWithoutProfessorInput> | Prisma.CourseProfessorCreateWithoutProfessorInput[] | Prisma.CourseProfessorUncheckedCreateWithoutProfessorInput[]
  connectOrCreate?: Prisma.CourseProfessorCreateOrConnectWithoutProfessorInput | Prisma.CourseProfessorCreateOrConnectWithoutProfessorInput[]
  createMany?: Prisma.CourseProfessorCreateManyProfessorInputEnvelope
  connect?: Prisma.CourseProfessorWhereUniqueInput | Prisma.CourseProfessorWhereUniqueInput[]
}

export type CourseProfessorUpdateManyWithoutProfessorNestedInput = {
  create?: Prisma.XOR<Prisma.CourseProfessorCreateWithoutProfessorInput, Prisma.CourseProfessorUncheckedCreateWithoutProfessorInput> | Prisma.CourseProfessorCreateWithoutProfessorInput[] | Prisma.CourseProfessorUncheckedCreateWithoutProfessorInput[]
  connectOrCreate?: Prisma.CourseProfessorCreateOrConnectWithoutProfessorInput | Prisma.CourseProfessorCreateOrConnectWithoutProfessorInput[]
  upsert?: Prisma.CourseProfessorUpsertWithWhereUniqueWithoutProfessorInput | Prisma.CourseProfessorUpsertWithWhereUniqueWithoutProfessorInput[]
  createMany?: Prisma.CourseProfessorCreateManyProfessorInputEnvelope
  set?: Prisma.CourseProfessorWhereUniqueInput | Prisma.CourseProfessorWhereUniqueInput[]
  disconnect?: Prisma.CourseProfessorWhereUniqueInput | Prisma.CourseProfessorWhereUniqueInput[]
  delete?: Prisma.CourseProfessorWhereUniqueInput | Prisma.CourseProfessorWhereUniqueInput[]
  connect?: Prisma.CourseProfessorWhereUniqueInput | Prisma.CourseProfessorWhereUniqueInput[]
  update?: Prisma.CourseProfessorUpdateWithWhereUniqueWithoutProfessorInput | Prisma.CourseProfessorUpdateWithWhereUniqueWithoutProfessorInput[]
  updateMany?: Prisma.CourseProfessorUpdateManyWithWhereWithoutProfessorInput | Prisma.CourseProfessorUpdateManyWithWhereWithoutProfessorInput[]
  deleteMany?: Prisma.CourseProfessorScalarWhereInput | Prisma.CourseProfessorScalarWhereInput[]
}

export type CourseProfessorUncheckedUpdateManyWithoutProfessorNestedInput = {
  create?: Prisma.XOR<Prisma.CourseProfessorCreateWithoutProfessorInput, Prisma.CourseProfessorUncheckedCreateWithoutProfessorInput> | Prisma.CourseProfessorCreateWithoutProfessorInput[] | Prisma.CourseProfessorUncheckedCreateWithoutProfessorInput[]
  connectOrCreate?: Prisma.CourseProfessorCreateOrConnectWithoutProfessorInput | Prisma.CourseProfessorCreateOrConnectWithoutProfessorInput[]
  upsert?: Prisma.CourseProfessorUpsertWithWhereUniqueWithoutProfessorInput | Prisma.CourseProfessorUpsertWithWhereUniqueWithoutProfessorInput[]
  createMany?: Prisma.CourseProfessorCreateManyProfessorInputEnvelope
  set?: Prisma.CourseProfessorWhereUniqueInput | Prisma.CourseProfessorWhereUniqueInput[]
  disconnect?: Prisma.CourseProfessorWhereUniqueInput | Prisma.CourseProfessorWhereUniqueInput[]
  delete?: Prisma.CourseProfessorWhereUniqueInput | Prisma.CourseProfessorWhereUniqueInput[]
  connect?: Prisma.CourseProfessorWhereUniqueInput | Prisma.CourseProfessorWhereUniqueInput[]
  update?: Prisma.CourseProfessorUpdateWithWhereUniqueWithoutProfessorInput | Prisma.CourseProfessorUpdateWithWhereUniqueWithoutProfessorInput[]
  updateMany?: Prisma.CourseProfessorUpdateManyWithWhereWithoutProfessorInput | Prisma.CourseProfessorUpdateManyWithWhereWithoutProfessorInput[]
  deleteMany?: Prisma.CourseProfessorScalarWhereInput | Prisma.CourseProfessorScalarWhereInput[]
}

export type CourseProfessorCreateNestedManyWithoutCourseInput = {
  create?: Prisma.XOR<Prisma.CourseProfessorCreateWithoutCourseInput, Prisma.CourseProfessorUncheckedCreateWithoutCourseInput> | Prisma.CourseProfessorCreateWithoutCourseInput[] | Prisma.CourseProfessorUncheckedCreateWithoutCourseInput[]
  connectOrCreate?: Prisma.CourseProfessorCreateOrConnectWithoutCourseInput | Prisma.CourseProfessorCreateOrConnectWithoutCourseInput[]
  createMany?: Prisma.CourseProfessorCreateManyCourseInputEnvelope
  connect?: Prisma.CourseProfessorWhereUniqueInput | Prisma.CourseProfessorWhereUniqueInput[]
}

export type CourseProfessorUncheckedCreateNestedManyWithoutCourseInput = {
  create?: Prisma.XOR<Prisma.CourseProfessorCreateWithoutCourseInput, Prisma.CourseProfessorUncheckedCreateWithoutCourseInput> | Prisma.CourseProfessorCreateWithoutCourseInput[] | Prisma.CourseProfessorUncheckedCreateWithoutCourseInput[]
  connectOrCreate?: Prisma.CourseProfessorCreateOrConnectWithoutCourseInput | Prisma.CourseProfessorCreateOrConnectWithoutCourseInput[]
  createMany?: Prisma.CourseProfessorCreateManyCourseInputEnvelope
  connect?: Prisma.CourseProfessorWhereUniqueInput | Prisma.CourseProfessorWhereUniqueInput[]
}

export type CourseProfessorUpdateManyWithoutCourseNestedInput = {
  create?: Prisma.XOR<Prisma.CourseProfessorCreateWithoutCourseInput, Prisma.CourseProfessorUncheckedCreateWithoutCourseInput> | Prisma.CourseProfessorCreateWithoutCourseInput[] | Prisma.CourseProfessorUncheckedCreateWithoutCourseInput[]
  connectOrCreate?: Prisma.CourseProfessorCreateOrConnectWithoutCourseInput | Prisma.CourseProfessorCreateOrConnectWithoutCourseInput[]
  upsert?: Prisma.CourseProfessorUpsertWithWhereUniqueWithoutCourseInput | Prisma.CourseProfessorUpsertWithWhereUniqueWithoutCourseInput[]
  createMany?: Prisma.CourseProfessorCreateManyCourseInputEnvelope
  set?: Prisma.CourseProfessorWhereUniqueInput | Prisma.CourseProfessorWhereUniqueInput[]
  disconnect?: Prisma.CourseProfessorWhereUniqueInput | Prisma.CourseProfessorWhereUniqueInput[]
  delete?: Prisma.CourseProfessorWhereUniqueInput | Prisma.CourseProfessorWhereUniqueInput[]
  connect?: Prisma.CourseProfessorWhereUniqueInput | Prisma.CourseProfessorWhereUniqueInput[]
  update?: Prisma.CourseProfessorUpdateWithWhereUniqueWithoutCourseInput | Prisma.CourseProfessorUpdateWithWhereUniqueWithoutCourseInput[]
  updateMany?: Prisma.CourseProfessorUpdateManyWithWhereWithoutCourseInput | Prisma.CourseProfessorUpdateManyWithWhereWithoutCourseInput[]
  deleteMany?: Prisma.CourseProfessorScalarWhereInput | Prisma.CourseProfessorScalarWhereInput[]
}

export type CourseProfessorUncheckedUpdateManyWithoutCourseNestedInput = {
  create?: Prisma.XOR<Prisma.CourseProfessorCreateWithoutCourseInput, Prisma.CourseProfessorUncheckedCreateWithoutCourseInput> | Prisma.CourseProfessorCreateWithoutCourseInput[] | Prisma.CourseProfessorUncheckedCreateWithoutCourseInput[]
  connectOrCreate?: Prisma.CourseProfessorCreateOrConnectWithoutCourseInput | Prisma.CourseProfessorCreateOrConnectWithoutCourseInput[]
  upsert?: Prisma.CourseProfessorUpsertWithWhereUniqueWithoutCourseInput | Prisma.CourseProfessorUpsertWithWhereUniqueWithoutCourseInput[]
  createMany?: Prisma.CourseProfessorCreateManyCourseInputEnvelope
  set?: Prisma.CourseProfessorWhereUniqueInput | Prisma.CourseProfessorWhereUniqueInput[]
  disconnect?: Prisma.CourseProfessorWhereUniqueInput | Prisma.CourseProfessorWhereUniqueInput[]
  delete?: Prisma.CourseProfessorWhereUniqueInput | Prisma.CourseProfessorWhereUniqueInput[]
  connect?: Prisma.CourseProfessorWhereUniqueInput | Prisma.CourseProfessorWhereUniqueInput[]
  update?: Prisma.CourseProfessorUpdateWithWhereUniqueWithoutCourseInput | Prisma.CourseProfessorUpdateWithWhereUniqueWithoutCourseInput[]
  updateMany?: Prisma.CourseProfessorUpdateManyWithWhereWithoutCourseInput | Prisma.CourseProfessorUpdateManyWithWhereWithoutCourseInput[]
  deleteMany?: Prisma.CourseProfessorScalarWhereInput | Prisma.CourseProfessorScalarWhereInput[]
}

export type CourseProfessorCreateWithoutProfessorInput = {
  id?: string
  course: Prisma.CourseCreateNestedOneWithoutProfessorsInput
}

export type CourseProfessorUncheckedCreateWithoutProfessorInput = {
  id?: string
  courseId: string
}

export type CourseProfessorCreateOrConnectWithoutProfessorInput = {
  where: Prisma.CourseProfessorWhereUniqueInput
  create: Prisma.XOR<Prisma.CourseProfessorCreateWithoutProfessorInput, Prisma.CourseProfessorUncheckedCreateWithoutProfessorInput>
}

export type CourseProfessorCreateManyProfessorInputEnvelope = {
  data: Prisma.CourseProfessorCreateManyProfessorInput | Prisma.CourseProfessorCreateManyProfessorInput[]
  skipDuplicates?: boolean
}

export type CourseProfessorUpsertWithWhereUniqueWithoutProfessorInput = {
  where: Prisma.CourseProfessorWhereUniqueInput
  update: Prisma.XOR<Prisma.CourseProfessorUpdateWithoutProfessorInput, Prisma.CourseProfessorUncheckedUpdateWithoutProfessorInput>
  create: Prisma.XOR<Prisma.CourseProfessorCreateWithoutProfessorInput, Prisma.CourseProfessorUncheckedCreateWithoutProfessorInput>
}

export type CourseProfessorUpdateWithWhereUniqueWithoutProfessorInput = {
  where: Prisma.CourseProfessorWhereUniqueInput
  data: Prisma.XOR<Prisma.CourseProfessorUpdateWithoutProfessorInput, Prisma.CourseProfessorUncheckedUpdateWithoutProfessorInput>
}

export type CourseProfessorUpdateManyWithWhereWithoutProfessorInput = {
  where: Prisma.CourseProfessorScalarWhereInput
  data: Prisma.XOR<Prisma.CourseProfessorUpdateManyMutationInput, Prisma.CourseProfessorUncheckedUpdateManyWithoutProfessorInput>
}

export type CourseProfessorScalarWhereInput = {
  AND?: Prisma.CourseProfessorScalarWhereInput | Prisma.CourseProfessorScalarWhereInput[]
  OR?: Prisma.CourseProfessorScalarWhereInput[]
  NOT?: Prisma.CourseProfessorScalarWhereInput | Prisma.CourseProfessorScalarWhereInput[]
  id?: Prisma.StringFilter<"CourseProfessor"> | string
  courseId?: Prisma.StringFilter<"CourseProfessor"> | string
  professorId?: Prisma.StringFilter<"CourseProfessor"> | string
}

export type CourseProfessorCreateWithoutCourseInput = {
  id?: string
  professor: Prisma.ProfessorCreateNestedOneWithoutCoursesInput
}

export type CourseProfessorUncheckedCreateWithoutCourseInput = {
  id?: string
  professorId: string
}

export type CourseProfessorCreateOrConnectWithoutCourseInput = {
  where: Prisma.CourseProfessorWhereUniqueInput
  create: Prisma.XOR<Prisma.CourseProfessorCreateWithoutCourseInput, Prisma.CourseProfessorUncheckedCreateWithoutCourseInput>
}

export type CourseProfessorCreateManyCourseInputEnvelope = {
  data: Prisma.CourseProfessorCreateManyCourseInput | Prisma.CourseProfessorCreateManyCourseInput[]
  skipDuplicates?: boolean
}

export type CourseProfessorUpsertWithWhereUniqueWithoutCourseInput = {
  where: Prisma.CourseProfessorWhereUniqueInput
  update: Prisma.XOR<Prisma.CourseProfessorUpdateWithoutCourseInput, Prisma.CourseProfessorUncheckedUpdateWithoutCourseInput>
  create: Prisma.XOR<Prisma.CourseProfessorCreateWithoutCourseInput, Prisma.CourseProfessorUncheckedCreateWithoutCourseInput>
}

export type CourseProfessorUpdateWithWhereUniqueWithoutCourseInput = {
  where: Prisma.CourseProfessorWhereUniqueInput
  data: Prisma.XOR<Prisma.CourseProfessorUpdateWithoutCourseInput, Prisma.CourseProfessorUncheckedUpdateWithoutCourseInput>
}

export type CourseProfessorUpdateManyWithWhereWithoutCourseInput = {
  where: Prisma.CourseProfessorScalarWhereInput
  data: Prisma.XOR<Prisma.CourseProfessorUpdateManyMutationInput, Prisma.CourseProfessorUncheckedUpdateManyWithoutCourseInput>
}

export type CourseProfessorCreateManyProfessorInput = {
  id?: string
  courseId: string
}

export type CourseProfessorUpdateWithoutProfessorInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  course?: Prisma.CourseUpdateOneRequiredWithoutProfessorsNestedInput
}

export type CourseProfessorUncheckedUpdateWithoutProfessorInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  courseId?: Prisma.StringFieldUpdateOperationsInput | string
}

export type CourseProfessorUncheckedUpdateManyWithoutProfessorInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  courseId?: Prisma.StringFieldUpdateOperationsInput | string
}

export type CourseProfessorCreateManyCourseInput = {
  id?: string
  professorId: string
}

export type CourseProfessorUpdateWithoutCourseInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  professor?: Prisma.ProfessorUpdateOneRequiredWithoutCoursesNestedInput
}

export type CourseProfessorUncheckedUpdateWithoutCourseInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  professorId?: Prisma.StringFieldUpdateOperationsInput | string
}

export type CourseProfessorUncheckedUpdateManyWithoutCourseInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  professorId?: Prisma.StringFieldUpdateOperationsInput | string
}



export type CourseProfessorSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  courseId?: boolean
  professorId?: boolean
  course?: boolean | Prisma.CourseDefaultArgs<ExtArgs>
  professor?: boolean | Prisma.ProfessorDefaultArgs<ExtArgs>
}, ExtArgs["result"]["courseProfessor"]>

export type CourseProfessorSelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  courseId?: boolean
  professorId?: boolean
  course?: boolean | Prisma.CourseDefaultArgs<ExtArgs>
  professor?: boolean | Prisma.ProfessorDefaultArgs<ExtArgs>
}, ExtArgs["result"]["courseProfessor"]>

export type CourseProfessorSelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  courseId?: boolean
  professorId?: boolean
  course?: boolean | Prisma.CourseDefaultArgs<ExtArgs>
  professor?: boolean | Prisma.ProfessorDefaultArgs<ExtArgs>
}, ExtArgs["result"]["courseProfessor"]>

export type CourseProfessorSelectScalar = {
  id?: boolean
  courseId?: boolean
  professorId?: boolean
}

export type CourseProfessorOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetOmit<"id" | "courseId" | "professorId", ExtArgs["result"]["courseProfessor"]>
export type CourseProfessorInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  course?: boolean | Prisma.CourseDefaultArgs<ExtArgs>
  professor?: boolean | Prisma.ProfessorDefaultArgs<ExtArgs>
}
export type CourseProfessorIncludeCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  course?: boolean | Prisma.CourseDefaultArgs<ExtArgs>
  professor?: boolean | Prisma.ProfessorDefaultArgs<ExtArgs>
}
export type CourseProfessorIncludeUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  course?: boolean | Prisma.CourseDefaultArgs<ExtArgs>
  professor?: boolean | Prisma.ProfessorDefaultArgs<ExtArgs>
}

export type $CourseProfessorPayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  name: "CourseProfessor"
  objects: {
    course: Prisma.$CoursePayload<ExtArgs>
    professor: Prisma.$ProfessorPayload<ExtArgs>
  }
  scalars: runtime.Types.Extensions.GetPayloadResult<{
    id: string
    courseId: string
    professorId: string
  }, ExtArgs["result"]["courseProfessor"]>
  composites: {}
}

export type CourseProfessorGetPayload<S extends boolean | null | undefined | CourseProfessorDefaultArgs> = runtime.Types.Result.GetResult<Prisma.$CourseProfessorPayload, S>

export type CourseProfessorCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> =
  Omit<CourseProfessorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit' | 'relationLoadStrategy'> & {
    select?: CourseProfessorCountAggregateInputType | true
  }

export interface CourseProfessorDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CourseProfessor'], meta: { name: 'CourseProfessor' } }
  /**
   * Find zero or one CourseProfessor that matches the filter.
   * @param {CourseProfessorFindUniqueArgs} args - Arguments to find a CourseProfessor
   * @example
   * // Get one CourseProfessor
   * const courseProfessor = await prisma.courseProfessor.findUnique({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUnique<T extends CourseProfessorFindUniqueArgs>(args: Prisma.SelectSubset<T, CourseProfessorFindUniqueArgs<ExtArgs>>): Prisma.Prisma__CourseProfessorClient<runtime.Types.Result.GetResult<Prisma.$CourseProfessorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find one CourseProfessor that matches the filter or throw an error with `error.code='P2025'`
   * if no matches were found.
   * @param {CourseProfessorFindUniqueOrThrowArgs} args - Arguments to find a CourseProfessor
   * @example
   * // Get one CourseProfessor
   * const courseProfessor = await prisma.courseProfessor.findUniqueOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUniqueOrThrow<T extends CourseProfessorFindUniqueOrThrowArgs>(args: Prisma.SelectSubset<T, CourseProfessorFindUniqueOrThrowArgs<ExtArgs>>): Prisma.Prisma__CourseProfessorClient<runtime.Types.Result.GetResult<Prisma.$CourseProfessorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first CourseProfessor that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {CourseProfessorFindFirstArgs} args - Arguments to find a CourseProfessor
   * @example
   * // Get one CourseProfessor
   * const courseProfessor = await prisma.courseProfessor.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirst<T extends CourseProfessorFindFirstArgs>(args?: Prisma.SelectSubset<T, CourseProfessorFindFirstArgs<ExtArgs>>): Prisma.Prisma__CourseProfessorClient<runtime.Types.Result.GetResult<Prisma.$CourseProfessorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first CourseProfessor that matches the filter or
   * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {CourseProfessorFindFirstOrThrowArgs} args - Arguments to find a CourseProfessor
   * @example
   * // Get one CourseProfessor
   * const courseProfessor = await prisma.courseProfessor.findFirstOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirstOrThrow<T extends CourseProfessorFindFirstOrThrowArgs>(args?: Prisma.SelectSubset<T, CourseProfessorFindFirstOrThrowArgs<ExtArgs>>): Prisma.Prisma__CourseProfessorClient<runtime.Types.Result.GetResult<Prisma.$CourseProfessorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find zero or more CourseProfessors that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {CourseProfessorFindManyArgs} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all CourseProfessors
   * const courseProfessors = await prisma.courseProfessor.findMany()
   * 
   * // Get first 10 CourseProfessors
   * const courseProfessors = await prisma.courseProfessor.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const courseProfessorWithIdOnly = await prisma.courseProfessor.findMany({ select: { id: true } })
   * 
   */
  findMany<T extends CourseProfessorFindManyArgs>(args?: Prisma.SelectSubset<T, CourseProfessorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$CourseProfessorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

  /**
   * Create a CourseProfessor.
   * @param {CourseProfessorCreateArgs} args - Arguments to create a CourseProfessor.
   * @example
   * // Create one CourseProfessor
   * const CourseProfessor = await prisma.courseProfessor.create({
   *   data: {
   *     // ... data to create a CourseProfessor
   *   }
   * })
   * 
   */
  create<T extends CourseProfessorCreateArgs>(args: Prisma.SelectSubset<T, CourseProfessorCreateArgs<ExtArgs>>): Prisma.Prisma__CourseProfessorClient<runtime.Types.Result.GetResult<Prisma.$CourseProfessorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Create many CourseProfessors.
   * @param {CourseProfessorCreateManyArgs} args - Arguments to create many CourseProfessors.
   * @example
   * // Create many CourseProfessors
   * const courseProfessor = await prisma.courseProfessor.createMany({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *     
   */
  createMany<T extends CourseProfessorCreateManyArgs>(args?: Prisma.SelectSubset<T, CourseProfessorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Create many CourseProfessors and returns the data saved in the database.
   * @param {CourseProfessorCreateManyAndReturnArgs} args - Arguments to create many CourseProfessors.
   * @example
   * // Create many CourseProfessors
   * const courseProfessor = await prisma.courseProfessor.createManyAndReturn({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Create many CourseProfessors and only return the `id`
   * const courseProfessorWithIdOnly = await prisma.courseProfessor.createManyAndReturn({
   *   select: { id: true },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  createManyAndReturn<T extends CourseProfessorCreateManyAndReturnArgs>(args?: Prisma.SelectSubset<T, CourseProfessorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$CourseProfessorPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

  /**
   * Delete a CourseProfessor.
   * @param {CourseProfessorDeleteArgs} args - Arguments to delete one CourseProfessor.
   * @example
   * // Delete one CourseProfessor
   * const CourseProfessor = await prisma.courseProfessor.delete({
   *   where: {
   *     // ... filter to delete one CourseProfessor
   *   }
   * })
   * 
   */
  delete<T extends CourseProfessorDeleteArgs>(args: Prisma.SelectSubset<T, CourseProfessorDeleteArgs<ExtArgs>>): Prisma.Prisma__CourseProfessorClient<runtime.Types.Result.GetResult<Prisma.$CourseProfessorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Update one CourseProfessor.
   * @param {CourseProfessorUpdateArgs} args - Arguments to update one CourseProfessor.
   * @example
   * // Update one CourseProfessor
   * const courseProfessor = await prisma.courseProfessor.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  update<T extends CourseProfessorUpdateArgs>(args: Prisma.SelectSubset<T, CourseProfessorUpdateArgs<ExtArgs>>): Prisma.Prisma__CourseProfessorClient<runtime.Types.Result.GetResult<Prisma.$CourseProfessorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Delete zero or more CourseProfessors.
   * @param {CourseProfessorDeleteManyArgs} args - Arguments to filter CourseProfessors to delete.
   * @example
   * // Delete a few CourseProfessors
   * const { count } = await prisma.courseProfessor.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
   */
  deleteMany<T extends CourseProfessorDeleteManyArgs>(args?: Prisma.SelectSubset<T, CourseProfessorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more CourseProfessors.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {CourseProfessorUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many CourseProfessors
   * const courseProfessor = await prisma.courseProfessor.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  updateMany<T extends CourseProfessorUpdateManyArgs>(args: Prisma.SelectSubset<T, CourseProfessorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more CourseProfessors and returns the data updated in the database.
   * @param {CourseProfessorUpdateManyAndReturnArgs} args - Arguments to update many CourseProfessors.
   * @example
   * // Update many CourseProfessors
   * const courseProfessor = await prisma.courseProfessor.updateManyAndReturn({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Update zero or more CourseProfessors and only return the `id`
   * const courseProfessorWithIdOnly = await prisma.courseProfessor.updateManyAndReturn({
   *   select: { id: true },
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  updateManyAndReturn<T extends CourseProfessorUpdateManyAndReturnArgs>(args: Prisma.SelectSubset<T, CourseProfessorUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$CourseProfessorPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

  /**
   * Create or update one CourseProfessor.
   * @param {CourseProfessorUpsertArgs} args - Arguments to update or create a CourseProfessor.
   * @example
   * // Update or create a CourseProfessor
   * const courseProfessor = await prisma.courseProfessor.upsert({
   *   create: {
   *     // ... data to create a CourseProfessor
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the CourseProfessor we want to update
   *   }
   * })
   */
  upsert<T extends CourseProfessorUpsertArgs>(args: Prisma.SelectSubset<T, CourseProfessorUpsertArgs<ExtArgs>>): Prisma.Prisma__CourseProfessorClient<runtime.Types.Result.GetResult<Prisma.$CourseProfessorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


  /**
   * Count the number of CourseProfessors.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {CourseProfessorCountArgs} args - Arguments to filter CourseProfessors to count.
   * @example
   * // Count the number of CourseProfessors
   * const count = await prisma.courseProfessor.count({
   *   where: {
   *     // ... the filter for the CourseProfessors we want to count
   *   }
   * })
  **/
  count<T extends CourseProfessorCountArgs>(
    args?: Prisma.Subset<T, CourseProfessorCountArgs>,
  ): Prisma.PrismaPromise<
    T extends runtime.Types.Utils.Record<'select', any>
      ? T['select'] extends true
        ? number
        : Prisma.GetScalarType<T['select'], CourseProfessorCountAggregateOutputType>
      : number
  >

  /**
   * Allows you to perform aggregations operations on a CourseProfessor.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {CourseProfessorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
   * @example
   * // Ordered by age ascending
   * // Where email contains prisma.io
   * // Limited to the 10 users
   * const aggregations = await prisma.user.aggregate({
   *   _avg: {
   *     age: true,
   *   },
   *   where: {
   *     email: {
   *       contains: "prisma.io",
   *     },
   *   },
   *   orderBy: {
   *     age: "asc",
   *   },
   *   take: 10,
   * })
  **/
  aggregate<T extends CourseProfessorAggregateArgs>(args: Prisma.Subset<T, CourseProfessorAggregateArgs>): Prisma.PrismaPromise<GetCourseProfessorAggregateType<T>>

  /**
   * Group by CourseProfessor.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {CourseProfessorGroupByArgs} args - Group by arguments.
   * @example
   * // Group by city, order by createdAt, get count
   * const result = await prisma.user.groupBy({
   *   by: ['city', 'createdAt'],
   *   orderBy: {
   *     createdAt: true
   *   },
   *   _count: {
   *     _all: true
   *   },
   * })
   * 
  **/
  groupBy<
    T extends CourseProfessorGroupByArgs,
    HasSelectOrTake extends Prisma.Or<
      Prisma.Extends<'skip', Prisma.Keys<T>>,
      Prisma.Extends<'take', Prisma.Keys<T>>
    >,
    OrderByArg extends Prisma.True extends HasSelectOrTake
      ? { orderBy: CourseProfessorGroupByArgs['orderBy'] }
      : { orderBy?: CourseProfessorGroupByArgs['orderBy'] },
    OrderFields extends Prisma.ExcludeUnderscoreKeys<Prisma.Keys<Prisma.MaybeTupleToUnion<T['orderBy']>>>,
    ByFields extends Prisma.MaybeTupleToUnion<T['by']>,
    ByValid extends Prisma.Has<ByFields, OrderFields>,
    HavingFields extends Prisma.GetHavingFields<T['having']>,
    HavingValid extends Prisma.Has<ByFields, HavingFields>,
    ByEmpty extends T['by'] extends never[] ? Prisma.True : Prisma.False,
    InputErrors extends ByEmpty extends Prisma.True
    ? `Error: "by" must not be empty.`
    : HavingValid extends Prisma.False
    ? {
        [P in HavingFields]: P extends ByFields
          ? never
          : P extends string
          ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
          : [
              Error,
              'Field ',
              P,
              ` in "having" needs to be provided in "by"`,
            ]
      }[HavingFields]
    : 'take' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "take", you also need to provide "orderBy"'
    : 'skip' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "skip", you also need to provide "orderBy"'
    : ByValid extends Prisma.True
    ? {}
    : {
        [P in OrderFields]: P extends ByFields
          ? never
          : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
      }[OrderFields]
  >(args: Prisma.SubsetIntersection<T, CourseProfessorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourseProfessorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
/**
 * Fields of the CourseProfessor model
 */
readonly fields: CourseProfessorFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for CourseProfessor.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__CourseProfessorClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
  readonly [Symbol.toStringTag]: "PrismaPromise"
  course<T extends Prisma.CourseDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.CourseDefaultArgs<ExtArgs>>): Prisma.Prisma__CourseClient<runtime.Types.Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  professor<T extends Prisma.ProfessorDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.ProfessorDefaultArgs<ExtArgs>>): Prisma.Prisma__ProfessorClient<runtime.Types.Result.GetResult<Prisma.$ProfessorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): runtime.Types.Utils.JsPromise<TResult1 | TResult2>
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): runtime.Types.Utils.JsPromise<T | TResult>
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>
}




/**
 * Fields of the CourseProfessor model
 */
export interface CourseProfessorFieldRefs {
  readonly id: Prisma.FieldRef<"CourseProfessor", 'String'>
  readonly courseId: Prisma.FieldRef<"CourseProfessor", 'String'>
  readonly professorId: Prisma.FieldRef<"CourseProfessor", 'String'>
}
    

// Custom InputTypes
/**
 * CourseProfessor findUnique
 */
export type CourseProfessorFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the CourseProfessor
   */
  select?: Prisma.CourseProfessorSelect<ExtArgs> | null
  /**
   * Omit specific fields from the CourseProfessor
   */
  omit?: Prisma.CourseProfessorOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.CourseProfessorInclude<ExtArgs> | null
  /**
   * Filter, which CourseProfessor to fetch.
   */
  where: Prisma.CourseProfessorWhereUniqueInput
  relationLoadStrategy?: Prisma.RelationLoadStrategy
}

/**
 * CourseProfessor findUniqueOrThrow
 */
export type CourseProfessorFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the CourseProfessor
   */
  select?: Prisma.CourseProfessorSelect<ExtArgs> | null
  /**
   * Omit specific fields from the CourseProfessor
   */
  omit?: Prisma.CourseProfessorOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.CourseProfessorInclude<ExtArgs> | null
  /**
   * Filter, which CourseProfessor to fetch.
   */
  where: Prisma.CourseProfessorWhereUniqueInput
  relationLoadStrategy?: Prisma.RelationLoadStrategy
}

/**
 * CourseProfessor findFirst
 */
export type CourseProfessorFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the CourseProfessor
   */
  select?: Prisma.CourseProfessorSelect<ExtArgs> | null
  /**
   * Omit specific fields from the CourseProfessor
   */
  omit?: Prisma.CourseProfessorOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.CourseProfessorInclude<ExtArgs> | null
  /**
   * Filter, which CourseProfessor to fetch.
   */
  where?: Prisma.CourseProfessorWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of CourseProfessors to fetch.
   */
  orderBy?: Prisma.CourseProfessorOrderByWithRelationInput | Prisma.CourseProfessorOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for CourseProfessors.
   */
  cursor?: Prisma.CourseProfessorWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` CourseProfessors from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` CourseProfessors.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of CourseProfessors.
   */
  distinct?: Prisma.CourseProfessorScalarFieldEnum | Prisma.CourseProfessorScalarFieldEnum[]
  relationLoadStrategy?: Prisma.RelationLoadStrategy
}

/**
 * CourseProfessor findFirstOrThrow
 */
export type CourseProfessorFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the CourseProfessor
   */
  select?: Prisma.CourseProfessorSelect<ExtArgs> | null
  /**
   * Omit specific fields from the CourseProfessor
   */
  omit?: Prisma.CourseProfessorOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.CourseProfessorInclude<ExtArgs> | null
  /**
   * Filter, which CourseProfessor to fetch.
   */
  where?: Prisma.CourseProfessorWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of CourseProfessors to fetch.
   */
  orderBy?: Prisma.CourseProfessorOrderByWithRelationInput | Prisma.CourseProfessorOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for CourseProfessors.
   */
  cursor?: Prisma.CourseProfessorWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` CourseProfessors from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` CourseProfessors.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of CourseProfessors.
   */
  distinct?: Prisma.CourseProfessorScalarFieldEnum | Prisma.CourseProfessorScalarFieldEnum[]
  relationLoadStrategy?: Prisma.RelationLoadStrategy
}

/**
 * CourseProfessor findMany
 */
export type CourseProfessorFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the CourseProfessor
   */
  select?: Prisma.CourseProfessorSelect<ExtArgs> | null
  /**
   * Omit specific fields from the CourseProfessor
   */
  omit?: Prisma.CourseProfessorOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.CourseProfessorInclude<ExtArgs> | null
  /**
   * Filter, which CourseProfessors to fetch.
   */
  where?: Prisma.CourseProfessorWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of CourseProfessors to fetch.
   */
  orderBy?: Prisma.CourseProfessorOrderByWithRelationInput | Prisma.CourseProfessorOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for listing CourseProfessors.
   */
  cursor?: Prisma.CourseProfessorWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` CourseProfessors from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` CourseProfessors.
   */
  skip?: number
  distinct?: Prisma.CourseProfessorScalarFieldEnum | Prisma.CourseProfessorScalarFieldEnum[]
  relationLoadStrategy?: Prisma.RelationLoadStrategy
}

/**
 * CourseProfessor create
 */
export type CourseProfessorCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the CourseProfessor
   */
  select?: Prisma.CourseProfessorSelect<ExtArgs> | null
  /**
   * Omit specific fields from the CourseProfessor
   */
  omit?: Prisma.CourseProfessorOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.CourseProfessorInclude<ExtArgs> | null
  /**
   * The data needed to create a CourseProfessor.
   */
  data: Prisma.XOR<Prisma.CourseProfessorCreateInput, Prisma.CourseProfessorUncheckedCreateInput>
  relationLoadStrategy?: Prisma.RelationLoadStrategy
}

/**
 * CourseProfessor createMany
 */
export type CourseProfessorCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to create many CourseProfessors.
   */
  data: Prisma.CourseProfessorCreateManyInput | Prisma.CourseProfessorCreateManyInput[]
  skipDuplicates?: boolean
}

/**
 * CourseProfessor createManyAndReturn
 */
export type CourseProfessorCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the CourseProfessor
   */
  select?: Prisma.CourseProfessorSelectCreateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the CourseProfessor
   */
  omit?: Prisma.CourseProfessorOmit<ExtArgs> | null
  /**
   * The data used to create many CourseProfessors.
   */
  data: Prisma.CourseProfessorCreateManyInput | Prisma.CourseProfessorCreateManyInput[]
  skipDuplicates?: boolean
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.CourseProfessorIncludeCreateManyAndReturn<ExtArgs> | null
}

/**
 * CourseProfessor update
 */
export type CourseProfessorUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the CourseProfessor
   */
  select?: Prisma.CourseProfessorSelect<ExtArgs> | null
  /**
   * Omit specific fields from the CourseProfessor
   */
  omit?: Prisma.CourseProfessorOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.CourseProfessorInclude<ExtArgs> | null
  /**
   * The data needed to update a CourseProfessor.
   */
  data: Prisma.XOR<Prisma.CourseProfessorUpdateInput, Prisma.CourseProfessorUncheckedUpdateInput>
  /**
   * Choose, which CourseProfessor to update.
   */
  where: Prisma.CourseProfessorWhereUniqueInput
  relationLoadStrategy?: Prisma.RelationLoadStrategy
}

/**
 * CourseProfessor updateMany
 */
export type CourseProfessorUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to update CourseProfessors.
   */
  data: Prisma.XOR<Prisma.CourseProfessorUpdateManyMutationInput, Prisma.CourseProfessorUncheckedUpdateManyInput>
  /**
   * Filter which CourseProfessors to update
   */
  where?: Prisma.CourseProfessorWhereInput
  /**
   * Limit how many CourseProfessors to update.
   */
  limit?: number
}

/**
 * CourseProfessor updateManyAndReturn
 */
export type CourseProfessorUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the CourseProfessor
   */
  select?: Prisma.CourseProfessorSelectUpdateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the CourseProfessor
   */
  omit?: Prisma.CourseProfessorOmit<ExtArgs> | null
  /**
   * The data used to update CourseProfessors.
   */
  data: Prisma.XOR<Prisma.CourseProfessorUpdateManyMutationInput, Prisma.CourseProfessorUncheckedUpdateManyInput>
  /**
   * Filter which CourseProfessors to update
   */
  where?: Prisma.CourseProfessorWhereInput
  /**
   * Limit how many CourseProfessors to update.
   */
  limit?: number
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.CourseProfessorIncludeUpdateManyAndReturn<ExtArgs> | null
}

/**
 * CourseProfessor upsert
 */
export type CourseProfessorUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the CourseProfessor
   */
  select?: Prisma.CourseProfessorSelect<ExtArgs> | null
  /**
   * Omit specific fields from the CourseProfessor
   */
  omit?: Prisma.CourseProfessorOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.CourseProfessorInclude<ExtArgs> | null
  /**
   * The filter to search for the CourseProfessor to update in case it exists.
   */
  where: Prisma.CourseProfessorWhereUniqueInput
  /**
   * In case the CourseProfessor found by the `where` argument doesn't exist, create a new CourseProfessor with this data.
   */
  create: Prisma.XOR<Prisma.CourseProfessorCreateInput, Prisma.CourseProfessorUncheckedCreateInput>
  /**
   * In case the CourseProfessor was found with the provided `where` argument, update it with this data.
   */
  update: Prisma.XOR<Prisma.CourseProfessorUpdateInput, Prisma.CourseProfessorUncheckedUpdateInput>
  relationLoadStrategy?: Prisma.RelationLoadStrategy
}

/**
 * CourseProfessor delete
 */
export type CourseProfessorDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the CourseProfessor
   */
  select?: Prisma.CourseProfessorSelect<ExtArgs> | null
  /**
   * Omit specific fields from the CourseProfessor
   */
  omit?: Prisma.CourseProfessorOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.CourseProfessorInclude<ExtArgs> | null
  /**
   * Filter which CourseProfessor to delete.
   */
  where: Prisma.CourseProfessorWhereUniqueInput
  relationLoadStrategy?: Prisma.RelationLoadStrategy
}

/**
 * CourseProfessor deleteMany
 */
export type CourseProfessorDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which CourseProfessors to delete
   */
  where?: Prisma.CourseProfessorWhereInput
  /**
   * Limit how many CourseProfessors to delete.
   */
  limit?: number
}

/**
 * CourseProfessor without action
 */
export type CourseProfessorDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the CourseProfessor
   */
  select?: Prisma.CourseProfessorSelect<ExtArgs> | null
  /**
   * Omit specific fields from the CourseProfessor
   */
  omit?: Prisma.CourseProfessorOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.CourseProfessorInclude<ExtArgs> | null
}
