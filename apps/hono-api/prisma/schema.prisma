generator client {
  provider        = "prisma-client"
  output          = "./generated"
  previewFeatures = ["relationJoins"]
  runtime         = "bun"
}

datasource db {
  provider = "postgresql"
}

// Audit Logs
model Log {
  id        Int      @id @default(autoincrement())
  message   String
  createdAt DateTime @default(now())

  @@map("log")
}

model Department {
  prefix     String      @id
  name       String
  professors Professor[]
  courses    Course[]

  @@map("department")
}

model Term {
  code      String    @id
  name      String
  isActive  Boolean
  startDate DateTime
  endDate   DateTime
  sections  Section[]

  @@map("term")
}

model Professor {
  id               String            @id
  rmpId            String?           @unique
  departmentPrefix String
  department       Department        @relation(fields: [departmentPrefix], references: [prefix], onDelete: Cascade)
  name             String
  designation      String            @default("Professor")
  officeLocation   String?
  email            String?
  phone            String?
  linkedinUrl      String?
  websiteUrl       String?
  imageUrl         String?
  lastPullFromRmp  DateTime?
  courses          CourseProfessor[]
  sections         Section[]
  ratings          Rating[]

  @@index([name])
  @@index([departmentPrefix])
  @@map("professor")
}

model Course {
  id                  String            @id
  code                String            @unique
  title               String
  description         String
  departmentPrefix    String
  matchingSectionIds  String[]
  department          Department        @relation(fields: [departmentPrefix], references: [prefix], onDelete: Cascade)
  credits             Int
  requisites          Json?
  lastSectionPulledAt DateTime?
  sections            Section[]
  professors          CourseProfessor[]
  ratings             Rating[]
  files               File[]

  @@index([departmentPrefix])
  @@map("course")
}

model Section {
  id                String     @id
  termCode          String
  term              Term       @relation(fields: [termCode], references: [code], onDelete: Cascade)
  sectionCode       String
  sectionSearchName String
  classStartTime    String
  classEndTime      String
  buildingName      String
  roomNumber        String
  days              Int[]
  courseId          String
  refreshedAt       DateTime
  instructorTBD     Boolean    @default(false)
  isOnline          Boolean    @default(false)
  course            Course     @relation(fields: [courseId], references: [id], onDelete: Cascade)
  professorId       String?
  professor         Professor? @relation(fields: [professorId], references: [id], onDelete: Cascade)

  @@index([courseId])
  @@index([professorId])
  @@index([termCode])
  @@map("section")
}

enum Status {
  PENDING_ANALYSIS
  APPROVED
  AI_FLAGGED
  USER_FLAGGED
  REJECTED
}

enum ReviewStatus {
  PENDING
  APPROVED
  REJECTED
}

model Flag {
  id           String       @id @default(uuid())
  ratingId     String?
  rating       Rating?      @relation(fields: [ratingId], references: [id], onDelete: Cascade)
  fileId       String?
  file         File?        @relation(fields: [fileId], references: [id], onDelete: Cascade)
  reason       String
  reviewStatus ReviewStatus
  createdAt    DateTime     @default(now())
  updatedAt    DateTime     @updatedAt
  userId       String?
  user         User?        @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([ratingId])
  @@index([fileId])
  @@index([reviewStatus])
  @@map("flag")
}

model Rating {
  id                 String    @id @default(uuid())
  rmpId              String?   @unique
  status             Status    @default(PENDING_ANALYSIS)
  quality            Int
  difficulty         Int
  isForCredit        Boolean?
  comment            String?
  textBookRequired   Boolean?
  attendanceRequired Boolean
  gradeReceived      String?
  wouldTakeAgain     Boolean?
  thumbsUpTotal      Int       @default(0)
  thumbsDownTotal    Int       @default(0)
  tags               String[]
  professorId        String
  professor          Professor @relation(fields: [professorId], references: [id], onDelete: Cascade)
  courseId           String
  course             Course    @relation(fields: [courseId], references: [id], onDelete: Cascade)
  postedAt           DateTime
  flags              Flag[]
  userId             String?
  user               User?     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([professorId])
  @@index([courseId])
  @@index([status])
  @@map("rating")
}

model CourseProfessor {
  id          String    @id @default(uuid())
  courseId    String
  professorId String
  course      Course    @relation(fields: [courseId], references: [id], onDelete: Cascade)
  professor   Professor @relation(fields: [professorId], references: [id], onDelete: Cascade)

  @@unique([courseId, professorId])
  @@index([courseId])
  @@index([professorId])
  @@map("course_professor")
}

model File {
  id        String   @id @default(uuid())
  name      String
  key       String   @unique
  mimeType  String
  size      Int
  courseId  String
  course    Course   @relation(fields: [courseId], references: [id], onDelete: Cascade)
  status    Status   @default(PENDING_ANALYSIS)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  userId    String?
  user      User?    @relation(fields: [userId], references: [id], onDelete: Cascade)
  flags     Flag[]

  @@index([courseId])
  @@index([status])
  @@map("file")
}

model User {
  id            String    @id @default(uuid())
  email         String    @unique
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  name          String
  emailVerified Boolean
  image         String?
  sessions      Session[]
  accounts      Account[]
  flags         Flag[]
  ratings       Rating[]
  files         File[]

  @@map("user")
}

// Better Auth
model Session {
  id        String   @id
  expiresAt DateTime
  token     String   @unique
  createdAt DateTime
  updatedAt DateTime
  ipAddress String?
  userAgent String?
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("session")
}

model Account {
  id                    String    @id
  accountId             String
  providerId            String
  userId                String
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  accessToken           String?
  refreshToken          String?
  idToken               String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  password              String?
  createdAt             DateTime
  updatedAt             DateTime

  @@map("account")
}

model Verification {
  id         String    @id
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime?
  updatedAt  DateTime?

  @@map("verification")
}
